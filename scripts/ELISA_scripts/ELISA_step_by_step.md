ELISA_step_by_step
================
Finn Lobnow
, Last edited on 06 February 2024

- [Load the necessary libraries and
  packages](#load-the-necessary-libraries-and-packages)
- [Standard Curve & Prediction of IL-2
  CONCENTRATIONs](#standard-curve--prediction-of-il-2-concentrations)

### Load the necessary libraries and packages

``` r
library(pacman)
pacman::p_load(data.table, ggplot2, lubridate, stringr, ggpubr, dplyr, cowplot)

# Set paths and load the raw data
MAIN <- "/Volumes/TAYLOR-LAB/Finn/ELISA"
MAIN <- "/Users/u_lobnow/Documents/etc/Desktop_Cleanup"

# 1. Specify folder with PLATEs to be analysed: PLATE names should be formatted as: PLATE_1_20220623 (PLATE_X_YYYYMMDD)
# 2. Specify where to store the Standard curve plots generated by the Elisa_Fx() function.
# 3. Specify where you would like to store the other figures generated by this script

Input_Directory <- file.path(MAIN, "ALL/")  
Output_Directory <- file.path(Input_Directory, "Output")

save_to = ifelse(test = dir.exists("/Volumes/TAYLOR-LAB/Finn/ELISA/figures"), 
                 yes = "/Volumes/TAYLOR-LAB/Finn/ELISA/figures",
                 no = "~/Desktop/ELISA_Plots/")   
```

4.  Specify where functions are stored or introduce necessary functions
    here.

``` r
source(file = ifelse(exists("https://raw.githubusercontent.com/tlobnow/coding_universe/main/scripts/functions.R"), 
                     yes =  "https://raw.githubusercontent.com/tlobnow/coding_universe/main/scripts/functions.R",
                     no  =  "~/Documents/Github/coding_universe/scripts/functions.R"))

filter_data <- function(DATA, FILTER_VALUES, FILTER_TYPE, POSITIVE_CTRL, NEGATIVE_CTRL) {
  filter_pattern_func <- if (FILTER_TYPE %in% "COHORT") {
    function(value, df) matches_any_pattern_vec(df$CELL_LINE, value) | matches_any_pattern_vec(df$CL_NAME_ON_PLOT, value)
  } else if (FILTER_TYPE %in% "DAY") {
    function(value, df) matches_any_pattern_vec(df$Date, value)
  } else {
    stop("Invalid FILTER_TYPE. Must be either 'COHORT' or 'DAY'.")
  }
  
  # Generate lists for plates, dates, and stim_days based on the filter type
  plates_list <- lapply(FILTER_VALUES, function(value) {
    DATA %>%
      filter(filter_pattern_func(value, DATA)) %>%
      distinct(Plate) %>%
      pull(Plate)
  })
  
  dates_list <- lapply(FILTER_VALUES, function(value) {
    DATA %>%
      filter(filter_pattern_func(value, DATA)) %>%
      distinct(Date) %>%
      pull(Date)
  })
  
  stim_list <- lapply(FILTER_VALUES, function(value) {
    DATA %>%
      filter(filter_pattern_func(value, DATA)) %>%
      distinct(STIM_DAY) %>%
      pull(STIM_DAY)
  })
  
  condition_list <- lapply(FILTER_VALUES, function(value) {
    DATA %>%
      filter(filter_pattern_func(value, DATA)) %>%
      distinct(CONDITION) %>%
      pull(CONDITION)
  })
  
  # Adding names to the list elements
  names(plates_list)    <- FILTER_VALUES
  names(dates_list)     <- FILTER_VALUES
  names(stim_list)      <- FILTER_VALUES
  names(condition_list) <- FILTER_VALUES
  
  # Create subset based on the lists
  subset_list <- lapply(names(plates_list), function(value) {
    plates <- plates_list[[value]]
    dates  <- dates_list[[value]]
    stim   <- stim_list[[value]]
    cond   <- condition_list[[value]]
    
    DATA %>%
      filter(Date %in% dates,
             Plate %in% plates,
             STIM_DAY %in% stim,
             CONDITION %in% cond,
             filter_pattern_func(c(POSITIVE_CTRL, NEGATIVE_CTRL, value), DATA))
  })
  
  # Combine the subsets and return
  FILTERED_SUBSET <- bind_rows(subset_list)
  return(FILTERED_SUBSET)
}

# DATA = FILTERED_SUBSET
calculate_baseline_and_control <- function(DATA, FILTER_TYPE, POSITIVE_CTRL, NEGATIVE_CTRL) {
  # Determine the group_by and filter parameters based on FILTER_TYPE
  if (FILTER_TYPE == "COHORT") {
    group_vars <- c("Date", "STIM_DAY")
    filter_var <- "CELL_LINE"
  } else if (FILTER_TYPE == "DAY") {
    group_vars <- c("Date", "STIM_DAY", "Plate")
    filter_var <- "CELL_LINE"  # Assuming the correct variable for DAY filter
  } else {
    stop("Invalid FILTER_TYPE. Must be either 'cohort' or 'day'.")
  }
  
  # Debugging information
  # print(paste("Grouping by:", paste(group_vars, collapse = ", ")))
  # print(paste("Filtering using variable:", filter_var))
  
  # Calculate the baseline control value
  if (is.character(NEGATIVE_CTRL)) {
    baseline <- DATA %>%
      group_by(!!!syms(group_vars)) %>%
      filter(matches_any_pattern_vec(!!sym(filter_var), NEGATIVE_CTRL), CONDITION == "UNSTIM") %>% 
      summarise(baseline_control_value = mean(Concentration))
    
    # Join the calculated values with the dataset
    data <- left_join(DATA, baseline, by = group_vars) %>%
      mutate(Concentration_REDUCED = case_when(!is.na(baseline_control_value) ~ Concentration - baseline_control_value, TRUE ~ Concentration))
  } else {
    baseline <- data %>%
      group_by(Date) %>%
      filter(Date == FILTER_VALUE) %>%
      summarise(baseline_control_value = min(Concentration))
    
    # Join the calculated values with the dataset
    data <- left_join(DATA, baseline) %>%
      mutate(Concentration_REDUCED = case_when(!is.na(baseline_control_value) ~ Concentration - baseline_control_value,
                                                               TRUE ~ Concentration))
  }
  
  
  if (is.character(POSITIVE_CTRL)) {
    control_mean_per_day <- data %>%
      filter(matches_any_pattern_vec(!!sym(filter_var), POSITIVE_CTRL), CONDITION == "STIM") %>% 
      group_by(!!!syms(group_vars)) %>%
      summarise(control_mean_MEASUREMENT = case_when(mean(Concentration_REDUCED) > 0 ~ mean(Concentration_REDUCED), TRUE ~ -Inf))
    
    # Join the calculated control means
    data <- left_join(data, control_mean_per_day, by = group_vars)
    
    # Perform normalization
    DATA_NORMALIZED <- data %>%
      group_by(!!!syms(group_vars), CELL_LINE, CONDITION) %>%
      mutate(Concentration_NORMALIZED = case_when(Concentration_REDUCED / control_mean_MEASUREMENT < 0 ~ 0,
                                                                  TRUE ~ Concentration_REDUCED / control_mean_MEASUREMENT),
             triplicate_mean_per_day = mean(Concentration_NORMALIZED)) %>%
      ungroup()
    
  } else {
    # Calculate control mean using an alternative method, e.g., mean value per group
    control_mean_per_day <- data %>%
      group_by(STIM_DAY) %>%
      reframe(Concentration_REDUCED = Concentration_REDUCED) %>%
      ungroup() %>%
      group_by(STIM_DAY) %>%
      reframe(control_MEASUREMENT = max(Concentration_REDUCED),
              STIM_DAY = STIM_DAY) %>%
      unique()
    
    # Join the calculated control means
    data <- left_join(data, control_mean_per_day)
    
    # Perform normalization
    DATA_NORMALIZED <- data %>%
      group_by(!!!syms(group_vars), CELL_LINE, CONDITION) %>%
      mutate(Concentration_NORMALIZED = case_when(Concentration_REDUCED / control_MEASUREMENT < 0 ~ 0,
                                                                  TRUE ~ Concentration_REDUCED / control_MEASUREMENT),
             triplicate_mean_per_day = mean(Concentration_NORMALIZED)) %>%
      ungroup()
  }
  
  return(DATA_NORMALIZED)
}

# DATA = DATA_NORMALIZED
perform_statistical_analysis <- function(DATA, GROUP_BY_COLUMN) {
  # Internal function for pairwise t-test
  pairwise_ttest <- function(DATA, return_annotation = FALSE) {
    p_values <- pairwise.t.test(DATA$triplicate_mean_per_day, DATA$CONDITION, p.adjust.method = "none")$p.value
    
    if (return_annotation) {
      p_annotation <- ifelse(p_values < 0.001, '***', 
                             ifelse(p_values < 0.01, '**', 
                                    ifelse(p_values < 0.05, '*', 
                                           'ns')))
      return(p_annotation)
    } else {
      return(formatC(p_values, format = "e", digits = 3))
    }
  }
  
  # Calculate statistical significance using a t-test for each group
  annotations <- sapply(split(DATA, DATA[[GROUP_BY_COLUMN]]), pairwise_ttest)
  p_values    <- sapply(split(DATA, DATA[[GROUP_BY_COLUMN]]), function(DATA) pairwise_ttest(DATA, return_annotation = TRUE))
  
  return(list(annotations = annotations, p_values = p_values))
}
```

5.  Specify names of the csv files per PLATE folder.

``` r
CELL_LINES    <- "CELL_LINES.csv"       # COHORT
STIM_DAYS     <- "STIMULATION_DAYS.csv" # SAMPLE_DAY
CONDITIONS    <- "CONDITIONS.csv"       # STIMULATION_CONDITION
MEASUREMENTS  <- "MEASUREMENTS.csv"     # VALUES_MEASURED
DILUTIONS     <- "DILUTIONS.csv"        # new addition that multiplied
NAME_KEY      <- fread(paste0(Input_Directory, "ELISA_CL_KEY.csv"))
```

### Standard Curve & Prediction of IL-2 CONCENTRATIONs

1.  Calculate the Standard Curve means
2.  Plot the Standard curve and fit a linear trend line

We use the equation to estimate IL-2 conc. of our unknown samples

Run ELISA_Fx() to generate standard curves and calculate the IL-2
CONCENTRATIONs

    ## [1] "Plates exist!"
    ## [1] "Secretion = slope*Intensity"
    ## [1] "Secretion = 313.82916069042*Intensity"

    ## [1] "Secretion = slope*Intensity"
    ## [1] "Secretion = 352.419126169057*Intensity"

    ## [1] "Secretion = slope*Intensity"
    ## [1] "Secretion = 486.430904744731*Intensity"

    ## [1] "Secretion = slope*Intensity"
    ## [1] "Secretion = 330.683712854235*Intensity"

    ## [1] "Secretion = slope*Intensity"
    ## [1] "Secretion = 320.070381583682*Intensity"

    ## [1] "Secretion = slope*Intensity"
    ## [1] "Secretion = 551.005853912264*Intensity"

    ## [1] "Secretion = slope*Intensity"
    ## [1] "Secretion = 339.16008462931*Intensity"

    ## [1] "Secretion = slope*Intensity"
    ## [1] "Secretion = 306.346853473382*Intensity"

    ## [1] "Secretion = slope*Intensity"
    ## [1] "Secretion = 512.336485628459*Intensity"

    ## [1] "Secretion = slope*Intensity"
    ## [1] "Secretion = 358.251952014523*Intensity"

    ## [1] "Secretion = slope*Intensity"
    ## [1] "Secretion = 298.804571083167*Intensity"

    ## [1] "Secretion = slope*Intensity"
    ## [1] "Secretion = 347.167928535214*Intensity"

    ## [1] "Secretion = slope*Intensity"
    ## [1] "Secretion = 559.423714931026*Intensity"

    ## [1] "Secretion = slope*Intensity"
    ## [1] "Secretion = 962.370999694574*Intensity"

    ## [1] "Secretion = slope*Intensity"
    ## [1] "Secretion = 780.346297971314*Intensity"

    ## [1] "Secretion = slope*Intensity"
    ## [1] "Secretion = 648.211009293357*Intensity"

    ## [1] "Secretion = slope*Intensity"
    ## [1] "Secretion = 1012.25564141243*Intensity"

    ## [1] "Secretion = slope*Intensity"
    ## [1] "Secretion = 343.305750019615*Intensity"

    ## [1] "Secretion = slope*Intensity"
    ## [1] "Secretion = 294.758249276599*Intensity"

    ## [1] "Secretion = slope*Intensity"
    ## [1] "Secretion = 224.743910185426*Intensity"

    ## [1] "Secretion = slope*Intensity"
    ## [1] "Secretion = 610.039946730864*Intensity"

    ## [1] "Secretion = slope*Intensity"
    ## [1] "Secretion = 58.1684699766724*Intensity"

    ## [1] "Secretion = slope*Intensity"
    ## [1] "Secretion = 912.75993655922*Intensity"

    ## [1] "Secretion = slope*Intensity"
    ## [1] "Secretion = 823.199489015732*Intensity"

    ## [1] "Secretion = slope*Intensity"
    ## [1] "Secretion = 952.102119113426*Intensity"

    ## [1] "Secretion = slope*Intensity"
    ## [1] "Secretion = 517.086137297724*Intensity"

    ## [1] "Secretion = slope*Intensity"
    ## [1] "Secretion = 248.240888395611*Intensity"

    ## [1] "Secretion = slope*Intensity"
    ## [1] "Secretion = 784.89151965658*Intensity"

    ## [1] "Secretion = slope*Intensity"
    ## [1] "Secretion = 872.843263404817*Intensity"

    ## [1] "Secretion = slope*Intensity"
    ## [1] "Secretion = 627.707303174028*Intensity"

    ## [1] "Secretion = slope*Intensity"
    ## [1] "Secretion = 241.683350098633*Intensity"

3.  Remove rows that have missing Measurements

``` r
All_plates_data <- All_plates_data %>% filter(!is.na(MEASUREMENT))
```

4.  Adjust column types as needed

``` r
# turn xyz into factors for easier handling downstream
All_plates_data$CONDITION <- as.factor(All_plates_data$CONDITION)
All_plates_data$STIM_DAY  <- as.factor(All_plates_data$STIM_DAY)
```

5.  Introduce colors based on color key

``` r
color_palette_key <- setNames(All_plates_data$PLOTTING_COLOR, All_plates_data$CELL_LINE)
color_palette_key <- unique(color_palette_key)
```

The following Column Names are in the final Data Frame:

``` r
str(All_plates_data)
```

    ## Classes 'data.table' and 'data.frame':   1826 obs. of  13 variables:
    ##  $ MEASUREMENT     : num  0.118 0.106 0.209 0.241 0.327 ...
    ##  $ CELL_LINE       : chr  "MyD88-GFP-synTRAF6-BD-1x" "MyD88-GFP-synTRAF6-BD-1x" "MyD88-GFP-synTRAF6-BD-1x" "MyD88-GFP-synTRAF6-BD-1x" ...
    ##  $ CONDITION       : Factor w/ 9 levels "0e+00","1e-01",..: 1 4 3 2 5 6 7 1 4 3 ...
    ##  $ STIM_DAY        : Factor w/ 4 levels "1","2","3","4": 1 1 1 1 1 1 1 1 1 1 ...
    ##  $ DILUTION        : num  5 5 5 5 5 5 5 5 5 5 ...
    ##  $ Plate           : num  1 1 1 1 1 1 1 1 1 1 ...
    ##  $ Date            : Date, format: "2022-10-06" "2022-10-06" ...
    ##  $ Concentration   : num  185 167 329 378 513 ...
    ##  $ Is_Dose_Response: logi  TRUE TRUE TRUE TRUE TRUE TRUE ...
    ##  $ CL_NUMBER       : logi  NA NA NA NA NA NA ...
    ##  $ CL_NAME_ON_PLOT : chr  "MyD88-sT6BM-1x" "MyD88-sT6BM-1x" "MyD88-sT6BM-1x" "MyD88-sT6BM-1x" ...
    ##  $ PLOTTING_COLOR  : chr  "#88CCEE" "#88CCEE" "#88CCEE" "#88CCEE" ...
    ##  $ ORDER_NO        : int  5 5 5 5 5 5 5 5 5 5 ...
    ##  - attr(*, ".internal.selfref")=<externalptr>

#### Mauriz Original Figure 1

``` r
# #read the tables
# Table_path <- 
#   c("/Volumes/TAYLOR-LAB/Synthetic Myddosome Paper/4_ELISA data/ELISA analysis in R/20220609_Elisa/Output/ELISA_Table.csv",
#     "/Volumes/TAYLOR-LAB/Synthetic Myddosome Paper/4_ELISA data/ELISA analysis in R/20220623_Elisa/Output/ELISA_Table.csv",
#     "/Volumes/TAYLOR-LAB/Synthetic Myddosome Paper/4_ELISA data/ELISA analysis in R/20220701_Elisa/Output/ELISA_Table.csv"
#   )
# 
# All_days_data <- data.frame()
# 
# for (Table in Table_path){
#   
#   All_plates_data <- fread(Table)
#   All_plates_data$Date <- (strsplit(strsplit(Table, "/")[[1]][7], "_"))[[1]][1]
#   All_days_data <- rbind(All_days_data, All_plates_data)
#   
#   rm(
#     All_plates_data
#   )
#   
# }
# 
# All_days_data$Stimulation_Condition <- factor(All_days_data$Stimulation_Condition, levels=c("Stimulated", "Unstimulated"))
# 
# #Standard error of the mean function
# sem <- function(x) sd(x)/sqrt(length(x))
# 
# chimeric_MyD88 <- 
#   All_days_data %>% 
#   filter(
#     Date %in% c("20220623", "20220701")
#   ) %>% 
#   group_by(
#     Sample_Day,
#     Date
#   ) %>% 
#   mutate(
#     Relative_Intensity = Values_Measured / max(Values_Measured[Cohort == "MyD88-GFP/ TRAF6-mScarlet" & Stimulation_Condition == "Stimulated"]))
# 
# chimeric_MyD88_data <- 
#   chimeric_MyD88 %>% 
#   filter(
#     Cohort %in% c("MyD88-T6BM", "MyD88-TIR-T6BM low", "MyD88-GFP/ TRAF6-mScarlet"),
#     Date == "20220623"
#   ) %>% 
#   mutate(
#     Cohort = case_when(
#       Cohort == "MyD88-GFP/ TRAF6-mScarlet" ~ "WT",
#       Cohort == "MyD88-T6BM" ~ "cMyD88",
#       Cohort == "MyD88-TIR-T6BM low" ~ "cMyD88-TIR")
#     )
# 
# Triple_KO <-
#   All_days_data %>% 
#   filter(
#     Date == "20220609",
#   ) %>% 
#   group_by(
#     Sample_Day,
#     Date
#   ) %>% 
#   mutate(
#     Relative_Intensity = Values_Measured / max(Values_Measured[Cohort == "WT" & Stimulation_Condition == "Stimulated"])
#     ) %>% 
#   filter(
#     Cohort == "MyD88-/-/ IRAK4-/-/\\n IRAK1-/-"
#   ) %>% 
#   mutate(
#     Cohort = case_when(
#       Cohort == "MyD88-/-/ IRAK4-/-/\\n IRAK1-/-" ~ "3xKO"))
# 
# chimeric_MyD88_3xA_data <- 
#   chimeric_MyD88 %>% 
#   filter(
#     Cohort %in% c("MyD88-T6BM-3xA"),
#     Date == "20220701"
#   ) %>% 
#   mutate(
#     Cohort = case_when(
#       Cohort == "MyD88-T6BM-3xA" ~ "cMyD88-3xA"))
# 
# chimeric_MyD88_data <- rbind(chimeric_MyD88_data, Triple_KO, chimeric_MyD88_3xA_data)
# 
# chimeric_MyD88_data$Cohort <-
#   factor(chimeric_MyD88_data$Cohort,
#          levels = rev(c( "WT", 
#                    "3xKO", 
#                    "cMyD88",
#                    "cMyD88-TIR",
#                    "cMyD88-3xA"
#          )))
# 
# chimeric_MyD88_test <-
#   chimeric_MyD88_data %>% 
#   mutate(
#     IL2_concentration_Dilution_Factor_mean = IL2_concentration_Dilution_Factor,
#     Relative_Intensity_mean = Relative_Intensity
#   ) %>% 
#   as.data.table()
# 
# chimeric_MyD88_plot <- 
#   chimeric_MyD88_data %>% 
#   group_by(
#     Cohort,
#     Stimulation_Condition,
#     Sample_Day
#   ) %>% 
#   summarise(
#     IL2_concentration_Dilution_Factor_mean = mean(IL2_concentration_Dilution_Factor),
#     Relative_Intensity_mean = mean(Relative_Intensity)
#   ) %>% 
#   as.data.table()
# 
# chimeric_MyD88_stats <-
#   chimeric_MyD88_data %>% 
#   group_by(
#     Cohort,
#     Stimulation_Condition
#   ) %>% 
#   summarise(
#     IL2_concentration_Dilution_Factor_mean = mean(IL2_concentration_Dilution_Factor),
#     IL2_concentration_Dilution_Factor_median = median(IL2_concentration_Dilution_Factor),
#     IL2_concentration_Dilution_Factor_sd = sd(IL2_concentration_Dilution_Factor),
#     Relative_Intensity_mean = mean(Relative_Intensity),
#     Relative_Intensity_sem = sem(Relative_Intensity)
#   ) %>% 
#   as.data.table()
# 
# color_elisa <- c("Unstimulated" = "white",
#                  "Stimulated" = "grey")
# 
# ggplot(
#   data = chimeric_MyD88_stats,
#   aes(
#     y = Cohort,
#     x = Relative_Intensity_mean,
#     fill = Stimulation_Condition
#   )
# ) +
#   geom_col(
#     position = position_dodge(width = 0.5),
#     color = "black",
#     width = 0.5
#   ) +
#   geom_errorbar(
#     data = chimeric_MyD88_stats,
#     aes(
#       y = Cohort,
#       xmin = Relative_Intensity_mean - Relative_Intensity_sem,
#       xmax = Relative_Intensity_mean + Relative_Intensity_sem
#     ),
#     linewidth = .75,
#     position = position_dodge(width = 0.5),
#     width = 0.25
#   ) +
#   geom_point(
#     data = chimeric_MyD88_plot,
#     aes(
#       y = Cohort,
#       x = Relative_Intensity_mean
#     ),
#     size = 0.75,
#     position = position_jitterdodge(dodge.width = 0.5, jitter.width = 0.4)
#   )+
#   # stat_compare_means(
#   #   data = chimeric_MyD88_test,
#   #   method = "wilcox.test",
#   #   label = "p.signif",
#   #   hide.ns = TRUE,
#   #   vjust = 0.9
#   # )+
#   scale_x_continuous(
#     breaks = seq(from = 0, to = 1, by = 0.5),
#     position = "top"
#   )+
#   scale_y_discrete(
#     expand = c(0,0)
#   )+
#   scale_fill_manual(
#     labels = c("+ IL-1", "- IL-1"),
#     values = c("grey40", "white")
#   )+
#   labs(
#     x = "IL-2 release (relative)"
#   )+
#   guides(
#     color = "none",
#     fill = guide_legend(nrow = 2)
#   )+
#   theme_classic(base_size = 8) +
#   theme(
#     axis.text.x = element_text(size = 8, 
#                                colour = "black",
#                                angle = 0,
#                                vjust = 0.6
#     ),
#     axis.title.y = element_blank(),
#     axis.text.y = element_blank(),
#     axis.title.x = element_text(size = 9),
#     legend.position = c(0.8,0.2),
#     legend.title = element_blank(),
#     legend.text = element_text(size = 9, color = "black"),
#     legend.key.size = unit(3, "mm"),
#   )
# 
# setwd("/Volumes/TAYLOR-LAB/Synthetic Myddosome Paper/Mock Figures/Figure 1")
# 
# ggsave(
#   "cl069_cl204_cl232_cl240_cl234_ELISA.pdf",
#   plot = last_plot(),
#   scale = 1,
#   units = "mm",
#   family = "Helvetica",
#   height = 95,
#   width = 42
# )
```

``` r
# FILTER_VALUES = c("MyD88-T6BD", "204_TRIPLE_KO", "tKO_EL4")
# FILTER_TYPE   = "COHORT"
# POSITIVE_CTRL = c("^69")
# NEGATIVE_CTRL = c("204_TRIPLE_KO", "tKO_EL4")
# COLOR = "cornflowerblue"
# x_label = ""
# y_label = "relative IL-2 conc."
# plot_title = "IL-2 ELISA"
# SEED = 600
# plot_pval = T
# plot_faceted_by_date = F
# 
# plot_by_cohorts <- plot_ELISA(FILTER_VALUES = FILTER_VALUES, 
#                               FILTER_TYPE   = FILTER_TYPE, 
#                               POSITIVE_CTRL = POSITIVE_CTRL, 
#                               NEGATIVE_CTRL = NEGATIVE_CTRL, 
#                               COLOR = COLOR)
# 
# plot_by_cohorts[1] 
# 
# COMBINED_DATA       <- as.data.frame(plot_by_cohorts[2])
# MEANS               <- as.data.frame(plot_by_cohorts[3])
# 
# MEANS <- COMBINED_DATA %>%
#     group_by(CELL_LINE, CONDITION) %>%
#     distinct(triplicate_mean_per_day, STIM_DAY, .keep_all = TRUE) %>%
#     ungroup()
# 
# 
# MOM_SUBSET          <- as.data.frame(plot_by_cohorts[4])
# STATISTICAL_RESULTS <- as.data.frame(plot_by_cohorts[5])
# 
# 
# ggplot(MEANS, aes(x = CL_NAME_ON_PLOT)) + 
#   geom_col(data = MOM_SUBSET,
#            aes(y = triplicate_mean_per_day, fill = CONDITION), position = position_dodge(width = 1), alpha = 0.5) +
#   geom_point(data = MEANS,
#              aes(y = triplicate_mean_per_day, group = CONDITION, shape = STIM_DAY),
#              position = position_jitterdodge(jitter.height = 0, jitter.width = 1.2, seed = SEED), 
#              col = "white", size = 4) +
#   geom_point(data = MEANS, aes(y = triplicate_mean_per_day, group = CONDITION, shape = STIM_DAY), 
#              position = position_jitterdodge(jitter.height = 0, jitter.width = 1.2, seed = SEED), 
#              col = "black", size = 3) +
#   geom_errorbar(data = MOM_SUBSET, aes(ymin = triplicate_mean_per_day - triplicate_sd_per_day, 
#                                        ymax = triplicate_mean_per_day + triplicate_sd_per_day, group = CONDITION), 
#                 width = 0.25, position = position_dodge(width = 1)) +
#     labs(x = x_label,
#          y = y_label) +
#     scale_fill_manual(values = c("UNSTIM" = "gray50", "STIM" = COLOR)) +
#     ggtitle(plot_title) +
#     theme_cowplot() +
#     theme(legend.position = "bottom") +
#     theme(plot.title = element_text(hjust = 0.5)) +
#   coord_flip()
```

#### New workflow for more freedom in analysis

``` r
# settings
DF = All_plates_data

# reorder for plotting
DF$CL_NAME_ON_PLOT <- reorder(DF$CL_NAME_ON_PLOT, DF$ORDER_NO)

# filter by cohorts
FILTER_VALUES = c("BDLD_57")
FILTER_TYPE   = "COHORT"

POSITIVE_CTRL = c("^69", "3E10_GFP")
NEGATIVE_CTRL = c("204_TRIPLE_KO", "tKO_EL4")

COLOR = "cornflowerblue"
x_label = ""
y_label = "relative IL-2 conc."
plot_title = "IL-2 ELISA"
subtitle = paste0("Assay performed for ", FILTER_VALUES, ", based on filter type ", FILTER_TYPE)

SEED = 600
plot_pval = T
plot_faceted_by_date = F
```

``` r
# processing ELISA
ALL_COHORT_DATA <- lapply(FILTER_VALUES, function(FILTER_VALUE) {
    # Step 1: Filter & Subset the main data into lists
    COHORT_DATA <- filter_data(DF, FILTER_VALUE, FILTER_TYPE, POSITIVE_CTRL, NEGATIVE_CTRL)
    # Step 2 and Step 3
    NORMALIZED_DATA <- calculate_baseline_and_control(COHORT_DATA, FILTER_TYPE, POSITIVE_CTRL, NEGATIVE_CTRL)
    return(NORMALIZED_DATA)
  })
```

    ## `summarise()` has grouped output by 'Date'. You can override using the
    ## `.groups` argument.
    ## `summarise()` has grouped output by 'Date'. You can override using the
    ## `.groups` argument.

``` r
# Step 4: Combine the subset lists into one data frame
COMBINED_DATA <- bind_rows(ALL_COHORT_DATA)
  
# Step 5: Calculate the means per cohort
MEANS <- COMBINED_DATA %>%
  group_by(CELL_LINE, CONDITION, Date) %>%
  distinct(triplicate_mean_per_day, STIM_DAY, .keep_all = TRUE) %>%
  ungroup()

MEANS$STIM_DAY <- as.factor(MEANS$STIM_DAY)


# Step 6: Calculate the mean of means (MOM) per cohort
MOM_SUBSET <- MEANS %>%
  group_by(CELL_LINE, CL_NAME_ON_PLOT, CONDITION, Date) %>%
  summarise(triplicate_sd_per_day = sd(triplicate_mean_per_day),
            triplicate_mean_per_day = mean(triplicate_mean_per_day)) %>%
  distinct(.keep_all = TRUE)
```

    ## `summarise()` has grouped output by 'CELL_LINE', 'CL_NAME_ON_PLOT',
    ## 'CONDITION'. You can override using the `.groups` argument.

``` r
# Step 7: Perform statistics per cohort
STATISTICAL_RESULTS <- perform_statistical_analysis(MEANS, "CL_NAME_ON_PLOT")

# str(COMBINED_DATA)
# str(MEANS)
# str(MOM_SUBSET)
# str(STATISTICAL_RESULTS)
```

``` r
ggplot(MEANS, aes(x = CL_NAME_ON_PLOT)) +
  geom_col(data = MOM_SUBSET,
           aes(y = triplicate_mean_per_day, fill = CONDITION), position = position_dodge(width = 1), alpha = 0.5) +
  geom_point(data = MEANS,
             aes(y = triplicate_mean_per_day, group = CONDITION, shape = STIM_DAY),
             position = position_jitterdodge(jitter.height = 0, jitter.width = 1.2, seed = SEED),
             col = "white", size = 4) +
  geom_point(data = MEANS, aes(y = triplicate_mean_per_day, group = CONDITION, shape = STIM_DAY),
             position = position_jitterdodge(jitter.height = 0, jitter.width = 1.2, seed = SEED),
             col = "black", size = 3) +
  geom_errorbar(data = MOM_SUBSET, aes(ymin = triplicate_mean_per_day - triplicate_sd_per_day,
                                       ymax = triplicate_mean_per_day + triplicate_sd_per_day, group = CONDITION),
                width = 0.25, position = position_dodge(width = 1)) +
    labs(x = x_label,
         y = y_label) +
    scale_fill_manual(values = c("UNSTIM" = "gray50", "STIM" = COLOR)) +
    ggtitle(plot_title) +
    theme_cowplot() +
    theme(legend.position = "bottom") +
    theme(plot.title = element_text(hjust = 0.5)) +
  coord_flip() +
  facet_wrap(~Date)
```

![](ELISA_step_by_step_files/figure-gfm/unnamed-chunk-13-1.png)<!-- -->
\#### ELISA Analysis per Date

``` r
# Sample vector of dates
dates <- unique(All_plates_data$Date)

# Order the vector of dates
ordered_dates <- dates[order(as.Date(dates))]

# Print the ordered dates
# print(ordered_dates)

for (date in ordered_dates) {
  print(as.IDate(date))
}
```

    ## [1] "2022-06-09"
    ## [1] "2022-06-23"
    ## [1] "2022-07-01"
    ## [1] "2022-10-06"
    ## [1] "2022-11-24"
    ## [1] "2022-12-08"
    ## [1] "2023-05-04"
    ## [1] "2023-05-12"
    ## [1] "2023-05-29"
    ## [1] "2023-06-21"
    ## [1] "2023-07-04"
    ## [1] "2023-10-18"
    ## [1] "2023-11-16"
    ## [1] "2024-01-31"

``` r
# DATE == "2022-06-09"

for (DATE in ordered_dates) {
  print(as.IDate(DATE))
  # settings
  DF = All_plates_data
  
  # reorder for plotting
  DF$CL_NAME_ON_PLOT <- reorder(DF$CL_NAME_ON_PLOT, -DF$ORDER_NO)
  
  # filter by day
  FILTER_VALUES = as.IDate(DATE)
  FILTER_TYPE   = "DAY"
  
  POSITIVE_CTRL = c("^69","WT_EL4")
  NEGATIVE_CTRL = c("204_TRIPLE_KO", "tKO_EL4")
  
  COLOR = "cornflowerblue"
  x_label = ""
  y_label = "relative IL-2 conc."
  plot_title = "IL-2 ELISA"
  subtitle = paste0("Assay performed for ", FILTER_VALUES, ", based on filter type ", FILTER_TYPE)
  
  SEED = 600
  plot_pval = T
  plot_faceted_by_date = F

  # processing ELISA
  ALL_COHORT_DATA <- lapply(FILTER_VALUES, function(FILTER_VALUE) {
      # Step 1: Filter & Subset the main data into lists
      COHORT_DATA <- filter_data(DF, FILTER_VALUE, FILTER_TYPE, POSITIVE_CTRL, NEGATIVE_CTRL)
      # Step 2 and Step 3
      NORMALIZED_DATA <- calculate_baseline_and_control(COHORT_DATA, FILTER_TYPE, POSITIVE_CTRL, NEGATIVE_CTRL)
      return(NORMALIZED_DATA)
    })
  
  # Step 4: Combine the subset lists into one data frame
  COMBINED_DATA <- bind_rows(ALL_COHORT_DATA)
    
  # Step 5: Calculate the means per cohort
  MEANS <- COMBINED_DATA %>%
    group_by(CELL_LINE, CONDITION, Date) %>%
    distinct(triplicate_mean_per_day, STIM_DAY, .keep_all = TRUE) %>%
    ungroup()
  
  MEANS$STIM_DAY <- as.factor(MEANS$STIM_DAY)
  
  
  # Step 6: Calculate the mean of means (MOM) per cohort
  MOM_SUBSET <- MEANS %>%
    group_by(CELL_LINE, CL_NAME_ON_PLOT, CONDITION, Date) %>%
    summarise(triplicate_sd_per_day = sd(triplicate_mean_per_day),
              triplicate_mean_per_day = mean(triplicate_mean_per_day)) %>%
    distinct(.keep_all = TRUE)
    
  # Step 7: Perform statistics per cohort
  STATISTICAL_RESULTS <- perform_statistical_analysis(MEANS, "CL_NAME_ON_PLOT")
  
  # Step 8: Plotting
  ggplot(MEANS, aes(x = CL_NAME_ON_PLOT)) +
    geom_col(data = MOM_SUBSET,
             aes(y = triplicate_mean_per_day, fill = CONDITION), position = position_dodge(width = 1), alpha = 0.5) +
    geom_point(data = MEANS,
               aes(y = triplicate_mean_per_day, group = CONDITION, shape = STIM_DAY),
               position = position_jitterdodge(jitter.height = 0, jitter.width = 1.2, seed = SEED),
               col = "white", size = 4) +
    geom_point(data = MEANS, aes(y = triplicate_mean_per_day, group = CONDITION, shape = STIM_DAY),
               position = position_jitterdodge(jitter.height = 0, jitter.width = 1.2, seed = SEED),
               col = "black", size = 3) +
    geom_errorbar(data = MOM_SUBSET, aes(ymin = triplicate_mean_per_day - triplicate_sd_per_day,
                                         ymax = triplicate_mean_per_day + triplicate_sd_per_day, group = CONDITION),
                  width = 0.25, position = position_dodge(width = 1)) +
      labs(x = x_label,
           y = y_label) +
      scale_fill_manual(values = c("UNSTIM" = "gray50", "STIM" = COLOR)) +
      ggtitle(plot_title) +
      theme_cowplot() +
      theme(legend.position = "bottom") +
      theme(plot.title = element_text(hjust = 0.5)) +
    coord_flip() +
    facet_wrap(~Date)
  
  
}
```

    ## [1] "2022-06-09"

    ## `summarise()` has grouped output by 'Date', 'STIM_DAY'. You can override using
    ## the `.groups` argument.
    ## `summarise()` has grouped output by 'Date', 'STIM_DAY'. You can override using
    ## the `.groups` argument.
    ## `summarise()` has grouped output by 'CELL_LINE', 'CL_NAME_ON_PLOT',
    ## 'CONDITION'. You can override using the `.groups` argument.

    ## [1] "2022-06-23"

    ## `summarise()` has grouped output by 'Date', 'STIM_DAY'. You can override using
    ## the `.groups` argument.
    ## `summarise()` has grouped output by 'Date', 'STIM_DAY'. You can override using
    ## the `.groups` argument.
    ## `summarise()` has grouped output by 'CELL_LINE', 'CL_NAME_ON_PLOT',
    ## 'CONDITION'. You can override using the `.groups` argument.

    ## [1] "2022-07-01"

    ## `summarise()` has grouped output by 'Date', 'STIM_DAY'. You can override using
    ## the `.groups` argument.
    ## `summarise()` has grouped output by 'Date', 'STIM_DAY'. You can override using
    ## the `.groups` argument.
    ## `summarise()` has grouped output by 'CELL_LINE', 'CL_NAME_ON_PLOT',
    ## 'CONDITION'. You can override using the `.groups` argument.

    ## [1] "2022-10-06"

    ## `summarise()` has grouped output by 'Date', 'STIM_DAY'. You can override using
    ## the `.groups` argument.
    ## `summarise()` has grouped output by 'Date', 'STIM_DAY'. You can override using
    ## the `.groups` argument.
    ## `summarise()` has grouped output by 'CELL_LINE', 'CL_NAME_ON_PLOT',
    ## 'CONDITION'. You can override using the `.groups` argument.

    ## [1] "2022-11-24"

    ## `summarise()` has grouped output by 'Date', 'STIM_DAY'. You can override using
    ## the `.groups` argument.
    ## `summarise()` has grouped output by 'Date', 'STIM_DAY'. You can override using
    ## the `.groups` argument.
    ## `summarise()` has grouped output by 'CELL_LINE', 'CL_NAME_ON_PLOT',
    ## 'CONDITION'. You can override using the `.groups` argument.

    ## [1] "2022-12-08"

    ## `summarise()` has grouped output by 'Date', 'STIM_DAY'. You can override using
    ## the `.groups` argument.
    ## `summarise()` has grouped output by 'Date', 'STIM_DAY'. You can override using
    ## the `.groups` argument.
    ## `summarise()` has grouped output by 'CELL_LINE', 'CL_NAME_ON_PLOT',
    ## 'CONDITION'. You can override using the `.groups` argument.

    ## [1] "2023-05-04"

    ## `summarise()` has grouped output by 'Date', 'STIM_DAY'. You can override using
    ## the `.groups` argument.
    ## `summarise()` has grouped output by 'Date', 'STIM_DAY'. You can override using
    ## the `.groups` argument.
    ## `summarise()` has grouped output by 'CELL_LINE', 'CL_NAME_ON_PLOT',
    ## 'CONDITION'. You can override using the `.groups` argument.

    ## [1] "2023-05-12"

    ## `summarise()` has grouped output by 'Date', 'STIM_DAY'. You can override using
    ## the `.groups` argument.
    ## `summarise()` has grouped output by 'Date', 'STIM_DAY'. You can override using
    ## the `.groups` argument.
    ## `summarise()` has grouped output by 'CELL_LINE', 'CL_NAME_ON_PLOT',
    ## 'CONDITION'. You can override using the `.groups` argument.

    ## [1] "2023-05-29"

    ## `summarise()` has grouped output by 'Date', 'STIM_DAY'. You can override using
    ## the `.groups` argument.
    ## `summarise()` has grouped output by 'Date', 'STIM_DAY'. You can override using
    ## the `.groups` argument.
    ## `summarise()` has grouped output by 'CELL_LINE', 'CL_NAME_ON_PLOT',
    ## 'CONDITION'. You can override using the `.groups` argument.

    ## [1] "2023-06-21"

    ## `summarise()` has grouped output by 'Date', 'STIM_DAY'. You can override using
    ## the `.groups` argument.
    ## `summarise()` has grouped output by 'Date', 'STIM_DAY'. You can override using
    ## the `.groups` argument.
    ## `summarise()` has grouped output by 'CELL_LINE', 'CL_NAME_ON_PLOT',
    ## 'CONDITION'. You can override using the `.groups` argument.

    ## [1] "2023-07-04"

    ## `summarise()` has grouped output by 'Date', 'STIM_DAY'. You can override using
    ## the `.groups` argument.
    ## `summarise()` has grouped output by 'Date', 'STIM_DAY'. You can override using
    ## the `.groups` argument.
    ## `summarise()` has grouped output by 'CELL_LINE', 'CL_NAME_ON_PLOT',
    ## 'CONDITION'. You can override using the `.groups` argument.

    ## [1] "2023-10-18"

    ## `summarise()` has grouped output by 'Date', 'STIM_DAY'. You can override using
    ## the `.groups` argument.
    ## `summarise()` has grouped output by 'Date', 'STIM_DAY'. You can override using
    ## the `.groups` argument.
    ## `summarise()` has grouped output by 'CELL_LINE', 'CL_NAME_ON_PLOT',
    ## 'CONDITION'. You can override using the `.groups` argument.

    ## [1] "2023-11-16"

    ## `summarise()` has grouped output by 'Date', 'STIM_DAY'. You can override using
    ## the `.groups` argument.
    ## `summarise()` has grouped output by 'Date', 'STIM_DAY'. You can override using
    ## the `.groups` argument.
    ## `summarise()` has grouped output by 'CELL_LINE', 'CL_NAME_ON_PLOT',
    ## 'CONDITION'. You can override using the `.groups` argument.

    ## [1] "2024-01-31"

    ## `summarise()` has grouped output by 'Date', 'STIM_DAY'. You can override using
    ## the `.groups` argument.
    ## `summarise()` has grouped output by 'Date', 'STIM_DAY'. You can override using
    ## the `.groups` argument.
    ## `summarise()` has grouped output by 'CELL_LINE', 'CL_NAME_ON_PLOT',
    ## 'CONDITION'. You can override using the `.groups` argument.

#### 2022-06-09 ELISA

``` r
# settings
DF = All_plates_data

# reorder for plotting
DF$CL_NAME_ON_PLOT <- reorder(DF$CL_NAME_ON_PLOT, -DF$ORDER_NO)

# filter by day
FILTER_VALUES = c("2022-06-09")
FILTER_TYPE   = "DAY"

POSITIVE_CTRL = c("^69","WT_EL4")
NEGATIVE_CTRL = c("204_TRIPLE_KO", "tKO_EL4")

COLOR = "cornflowerblue"
x_label = ""
y_label = "relative IL-2 conc."
plot_title = "IL-2 ELISA"
subtitle = paste0("Assay performed for ", FILTER_VALUES, ", based on filter type ", FILTER_TYPE)

SEED = 600
plot_pval = T
plot_faceted_by_date = F

#******************************************************************************#
#******************************************************************************#
#******************************************************************************#

# processing ELISA
ALL_COHORT_DATA <- lapply(FILTER_VALUES, function(FILTER_VALUE) {
    # Step 1: Filter & Subset the main data into lists
    COHORT_DATA <- filter_data(DF, FILTER_VALUE, FILTER_TYPE, POSITIVE_CTRL, NEGATIVE_CTRL)
    # Step 2 and Step 3
    NORMALIZED_DATA <- calculate_baseline_and_control(COHORT_DATA, FILTER_TYPE, POSITIVE_CTRL, NEGATIVE_CTRL)
    return(NORMALIZED_DATA)
  })
```

    ## `summarise()` has grouped output by 'Date', 'STIM_DAY'. You can override using
    ## the `.groups` argument.
    ## `summarise()` has grouped output by 'Date', 'STIM_DAY'. You can override using
    ## the `.groups` argument.

``` r
# Step 4: Combine the subset lists into one data frame
COMBINED_DATA <- bind_rows(ALL_COHORT_DATA)
  
# Step 5: Calculate the means per cohort
MEANS <- COMBINED_DATA %>%
  group_by(CELL_LINE, CONDITION, Date) %>%
  distinct(triplicate_mean_per_day, STIM_DAY, .keep_all = TRUE) %>%
  ungroup()

MEANS$STIM_DAY <- as.factor(MEANS$STIM_DAY)


# Step 6: Calculate the mean of means (MOM) per cohort
MOM_SUBSET <- MEANS %>%
  group_by(CELL_LINE, CL_NAME_ON_PLOT, CONDITION, Date) %>%
  summarise(triplicate_sd_per_day = sd(triplicate_mean_per_day),
            triplicate_mean_per_day = mean(triplicate_mean_per_day)) %>%
  distinct(.keep_all = TRUE)
```

    ## `summarise()` has grouped output by 'CELL_LINE', 'CL_NAME_ON_PLOT',
    ## 'CONDITION'. You can override using the `.groups` argument.

``` r
# Step 7: Perform statistics per cohort
STATISTICAL_RESULTS <- perform_statistical_analysis(MEANS, "CL_NAME_ON_PLOT")

# Step 8: Plotting
ggplot(MEANS, aes(x = CL_NAME_ON_PLOT)) +
  geom_col(data = MOM_SUBSET,
           aes(y = triplicate_mean_per_day, fill = CONDITION), position = position_dodge(width = 1), alpha = 0.5) +
  geom_point(data = MEANS,
             aes(y = triplicate_mean_per_day, group = CONDITION, shape = STIM_DAY),
             position = position_jitterdodge(jitter.height = 0, jitter.width = 1.2, seed = SEED),
             col = "white", size = 4) +
  geom_point(data = MEANS, aes(y = triplicate_mean_per_day, group = CONDITION, shape = STIM_DAY),
             position = position_jitterdodge(jitter.height = 0, jitter.width = 1.2, seed = SEED),
             col = "black", size = 3) +
  geom_errorbar(data = MOM_SUBSET, aes(ymin = triplicate_mean_per_day - triplicate_sd_per_day,
                                       ymax = triplicate_mean_per_day + triplicate_sd_per_day, group = CONDITION),
                width = 0.25, position = position_dodge(width = 1)) +
    labs(x = x_label,
         y = y_label) +
    scale_fill_manual(values = c("UNSTIM" = "gray50", "STIM" = COLOR)) +
    ggtitle(plot_title) +
    theme_cowplot() +
    theme(legend.position = "bottom") +
    theme(plot.title = element_text(hjust = 0.5)) +
  coord_flip() +
  facet_wrap(~Date)
```

![](ELISA_step_by_step_files/figure-gfm/unnamed-chunk-16-1.png)<!-- -->
